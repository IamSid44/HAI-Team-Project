#include "SAmxn.h" // This now includes System, Controller, SA, and PE
// L1.h is included by SAmxn.h
#include <iostream>
#include <iomanip> 
#include <cmath>   
#include <vector>
#include <fstream> // For writing the config file

// =================================================================
// --- Test Configuration ---
// =================================================================
#ifndef K1_DIM
#define K1_DIM 5
#endif

#ifndef K2_DIM
#define K2_DIM 5
#endif

#ifndef K3_DIM
#define K3_DIM 5
#endif

// Set the mode for this test run
// false = Weight Stationary
// true  = Output Stationary
const bool TEST_MODE_IS_OS = false; 

// --- NEW: Memory Base Addresses ---
const int A_BASE_ADDR = 0;
const int W_BASE_ADDR = 20000;
const int C_BASE_ADDR = 40000;
const int MEMORY_SIZE = 65536;

using namespace std;

SC_MODULE(SA_MxN_tb)
{
    // --- Test Data (Golden Model) ---
    float* A_mat_golden; // K1 x K2
    float* W_mat_golden; // K2 x K3
    float* C_mat_golden; // K1 x K3 (Result from SW)
    // C_mat_hw is no longer a pointer, it will be read from L1

    // Clock and reset
    sc_clock clk;
    sc_signal<bool> reset;

    // --- Controller I/O Signals ---
    sc_signal<bool> start;
    sc_signal<bool> done;

    sc_signal<bool> sa_output_stationary_in;

    sc_signal<int> K1, K2, K3;
    // --- NEW: Address Signals ---
    sc_signal<int> A_base_in, W_base_in, C_base_in;


    // DUT (Device Under Test) instance
    System* system_inst; // ** NEW: Instantiate System **

    // Helper function to print a 1D-flat matrix
    void print_matrix(const char* name, float* matrix, int rows, int cols) {
        cout << "--- " << name << " (" << rows << "x" << cols << ") ---" << endl;
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                cout << std::setw(8) << std::setprecision(2) << matrix[i * cols + j] << " ";
            }
            cout << endl;
        }
        cout << "------------------------------------" << endl;
    }

    // Helper to allocate and init a 1D matrix
    float* allocate_matrix(int rows, int cols, bool init_zeros = false) {
        float* matrix = new float[rows * cols];
        if (init_zeros) {
            for (int i = 0; i < rows * cols; ++i) matrix[i] = 0.0f;
        }
        return matrix;
    }

    // --- NEW: Function to write L1 config file ---
    void create_l1_config_file() {
        cout << "Generating L1_config.txt..." << endl;
        ofstream config_file("L1_config.txt");
        
        config_file << "# Auto-generated by SAmxn_tb.cpp" << endl;
        config_file << "MEMORY_SIZE " << MEMORY_SIZE << endl << endl;
        
        // --- Write A Matrix ---
        config_file << "BANK 0" << endl;
        config_file << "# A Matrix Data (K1xK2 = " << K1_DIM << "x" << K2_DIM << ")" << endl;
        for (int i = 0; i < K1_DIM; ++i) {
            for (int j = 0; j < K2_DIM; ++j) {
                int addr = A_BASE_ADDR + i * K2_DIM + j;
                A_mat_golden[i * K2_DIM + j] = i + 1; // Init A
                config_file << addr << " " << A_mat_golden[i * K2_DIM + j] << endl;
            }
        }
        
        // --- Write W Matrix ---
        config_file << endl << "# W Matrix Data (K2xK3 = " << K2_DIM << "x" << K3_DIM << ")" << endl;
         for (int i = 0; i < K2_DIM; ++i) {
            for (int j = 0; j < K3_DIM; ++j) {
                int addr = W_BASE_ADDR + i * K3_DIM + j;
                W_mat_golden[i * K3_DIM + j] = j + 1; // Init W
                config_file << addr << " " << W_mat_golden[i * K3_DIM + j] << endl;
            }
        }
        
        // C matrix is not pre-loaded, it's written by the SA
        // In WS mode, it must be zero-initialized. L1 handles this
        // by default (reading a non-existent key returns 0).
        
        config_file.close();
        cout << "L1_config.txt generated." << endl;
    }


    // --- Constructor ---
    SC_CTOR(SA_MxN_tb) : clk("clk", 10, SC_NS)
    {
        cout << "=== Testbench Configuration ===" << endl;
        cout << "Physical Grid: M=" << M << ", N=" << N << endl;
        cout << "Logical MatMul: K1=" << K1_DIM << ", K2=" << K2_DIM << ", K3=" << K3_DIM << endl;
        cout << "Test Mode: " << (TEST_MODE_IS_OS ? "Output Stationary" : "Weight Stationary") << endl;


        // --- 1. Allocate Golden Matrices ---
        A_mat_golden = allocate_matrix(K1_DIM, K2_DIM);
        W_mat_golden = allocate_matrix(K2_DIM, K3_DIM);
        C_mat_golden = allocate_matrix(K1_DIM, K3_DIM, true); // Must be zero-initialized!
        
        // --- 2. Create L1 Config File ---
        // This function also initializes A_mat_golden and W_mat_golden
        create_l1_config_file();

        
        cout << "\nCalculating Golden Model..." << endl;
        // --- 3. Calculate and Print Expected "Golden" Result ---
        for (int i = 0; i < K1_DIM; ++i) {
            for (int j = 0; j < K3_DIM; ++j) {
                for (int k = 0; k < K2_DIM; ++k) {
                    C_mat_golden[i * K3_DIM + j] += A_mat_golden[i * K2_DIM + k] * W_mat_golden[k * K3_DIM + j];
                }
            }
        }
        
        if (K1_DIM <= 10 && K2_DIM <= 10 && K3_DIM <= 10) {
            print_matrix("A_mat (Golden)", A_mat_golden, K1_DIM, K2_DIM);
            print_matrix("W_mat (Golden)", W_mat_golden, K2_DIM, K3_DIM);
            print_matrix("Expected Golden Result (C)", C_mat_golden, K1_DIM, K3_DIM);
        } else {
            cout << "Matrices are large, skipping print. Golden model is calculated." << endl;
        }


        // --- 4. Instantiate and Connect DUT ---
        system_inst = new System("system_inst");
        
        system_inst->clk(clk);
        system_inst->reset(reset);
        system_inst->start(start);
        system_inst->done(done);
        
        system_inst->sa_mode_is_output_stationary(sa_output_stationary_in);

        system_inst->K1(K1);
        system_inst->K2(K2);
        system_inst->K3(K3);
        
        system_inst->A_base_addr(A_base_in);
        system_inst->W_base_addr(W_base_in);
        system_inst->C_base_addr(C_base_in);


        cout << "\nSystem Testbench Created." << endl;
        SC_CTHREAD(testbench, clk);
    }

    // --- 5. Testbench Process ---
    void testbench()
    {
        cout << "Starting Testbench Process..." << endl;
        // --- Reset Phase ---
        reset.write(true);
        start.write(false);
        sa_output_stationary_in.write(false); // Default
        K1.write(0); K2.write(0); K3.write(0);
        A_base_in.write(0); W_base_in.write(0); C_base_in.write(0);
        wait(2);
        reset.write(false);
        wait();

        // --- Setup and Start ---
        cout << "@" << sc_time_stamp() << ": Setting up controller inputs." << endl;
        K1.write(K1_DIM);
        K2.write(K2_DIM);
        K3.write(K3_DIM);
        
        A_base_in.write(A_BASE_ADDR);
        W_base_in.write(W_BASE_ADDR);
        C_base_in.write(C_BASE_ADDR);
        
        sa_output_stationary_in.write(TEST_MODE_IS_OS);
        
        wait(); // Let signals propagate

        cout << "@" << sc_time_stamp() << ": Asserting Start signal." << endl;
        start.write(true);
        wait();
        start.write(false);
        
        // --- Wait for Completion ---
        cout << "@" << sc_time_stamp() << ": Waiting for 'done' signal..." << endl;
        while(done.read() == false) {
            wait();
        }

        cout << "@" << sc_time_stamp() << ": 'done' signal received! Computation finished." << endl;
        wait(5); // Wait a few extra cycles

        // --- 6. Verify Results ---
        cout << "\n=== Verification Phase ===" << endl;
        
        // ** NEW: Read results back from L1 memory **
        cout << "Reading HW results from L1 Memory..." << endl;
        float* C_mat_hw = allocate_matrix(K1_DIM, K3_DIM, true);
        
        for (int i = 0; i < K1_DIM; ++i) {
            for (int j = 0; j < K3_DIM; ++j) {
                int addr = C_BASE_ADDR + i * K3_DIM + j;
                // Use the debug read function
                C_mat_hw[i * K3_DIM + j] = system_inst->l1_mem->read_debug(addr);
            }
        }
        
        
        if (K1_DIM <= 10 && K3_DIM <= 10) {
            print_matrix("Actual HW Result (C)", C_mat_hw, K1_DIM, K3_DIM);
        }

        bool pass = true;
        double max_error = 0.0;
        for (int i = 0; i < K1_DIM * K3_DIM; ++i) {
            double error = fabs(C_mat_golden[i] - C_mat_hw[i]);
            if (error > max_error) max_error = error;
            
            if (error > 1e-5) { 
                pass = false;
            }
        }
        
        cout << "------------------------------------" << endl;
        if (pass) {
            cout << "✅ TEST PASSED!" << endl;
        } else {
            cout << "❌ TEST FAILED!" << endl;
        }
        cout << "Max error: " << max_error << endl;
        cout << "------------------------------------" << endl;

        sc_stop();
        
        // Clean up HW matrix
        delete[] C_mat_hw;
    }

    // --- 7. Destructor ---
    ~SA_MxN_tb()
    {
        delete system_inst;
        delete[] A_mat_golden;
        delete[] W_mat_golden;
        delete[] C_mat_golden;
    }
};


// --- sc_main ---
int sc_main(int argc, char* argv[]) {
    const char* vcd_name = (argc > 1) ? argv[1] : "SA_with_L1_tb";

    cout << "=================================================" << endl;
    cout << "=== SA_" << M << "x" << N << " with L1 Simulation ===" << endl;
    cout << "VCD Trace File: " << vcd_name << ".vcd" << endl;
    cout << "=================================================" << endl << endl;
    
    SA_MxN_tb system_tb("SA_MxN_tb_inst");

    sc_trace_file* tf = sc_create_vcd_trace_file(vcd_name);
    if (tf) {
        tf->set_time_unit(1, SC_NS);
        
        // --- Trace Top-Level Signals ---
        cout << "Tracing top-level signals..." << endl;
        sc_trace(tf, system_tb.clk, "clk");
        sc_trace(tf, system_tb.reset, "reset");
        sc_trace(tf, system_tb.start, "start");
        sc_trace(tf, system_tb.done, "done");
        sc_trace(tf, system_tb.K1, "K1");
        sc_trace(tf, system_tb.K2, "K2");
        sc_trace(tf, system_tb.K3, "K3");
        sc_trace(tf, system_tb.A_base_in, "A_base_in");
        sc_trace(tf, system_tb.W_base_in, "W_base_in");
        sc_trace(tf, system_tb.C_base_in, "C_base_in");
        sc_trace(tf, system_tb.sa_output_stationary_in, "sa_output_stationary_in");

        // --- Trace Controller -> L1 Signals ---
        cout << "Tracing Controller <-> L1 signals..." << endl;
        for (int i = 0; i < N; i++) {
            string name = "system.mem_addr_top_" + std::to_string(i);
            sc_trace(tf, system_tb.system_inst->mem_addr_top[i], name);
            
            name = "system.mem_data_top_" + std::to_string(i);
            sc_trace(tf, system_tb.system_inst->mem_data_top[i], name);
            
            name = "system.mem_write_addr_" + std::to_string(i);
            sc_trace(tf, system_tb.system_inst->mem_write_addr[i], name);

            name = "system.mem_write_en_" + std::to_string(i);
            sc_trace(tf, system_tb.system_inst->mem_write_en[i], name);

            name = "system.sa_to_l1_bottom_data_" + std::to_string(i);
            sc_trace(tf, system_tb.system_inst->sa_to_l1_bottom_data[i], name);
        }
        for (int i = 0; i < M; i++) {
            string name = "system.mem_addr_left_" + std::to_string(i);
            sc_trace(tf, system_tb.system_inst->mem_addr_left[i], name);

            name = "system.mem_data_left_" + std::to_string(i);
            sc_trace(tf, system_tb.system_inst->mem_data_left[i], name);
        }

        // --- Trace PE-level signals ---
        cout << "Tracing PE[0][0] internal signals..." << endl;
        PE* pe00 = system_tb.system_inst->controller->sa_grid->pe_array[0][0];
        sc_trace(tf, pe00->in_top, "system.controller.sa_grid.PE_0_0.in_top");
        sc_trace(tf, pe00->in_left, "system.controller.sa_grid.PE_0_0.in_left");
        sc_trace(tf, pe00->out_right, "system.controller.sa_grid.PE_0_0.out_right");
        sc_trace(tf, pe00->out_bottom, "system.controller.sa_grid.PE_0_0.out_bottom");
        sc_trace(tf, pe00->accumulator_buffer, "system.controller.sa_grid.PE_0_0.accumulator_buffer");

    } else {
        cout << "Error: Could not create VCD trace file." << endl;
    }

    cout << "\nStarting sc_start..." << endl << endl;
    sc_start(); // Run until sc_stop()
    cout << "\n=== Simulation Results ===" << endl;
    cout << "Simulation completed at time: " << sc_time_stamp() << endl;
    
    if (tf) {
        sc_close_vcd_trace_file(tf);
    }
    return 0;
}